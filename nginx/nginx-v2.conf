events {}

http {
    upstream frontend {
        server shorts-frontend-v2:3000;
    }

    upstream backend {
        server shorts-science-v2:8080; # Default routing, potentially dynamic based entirely on path, but here we assume a primary or round-robin if not specified. 
        # Actually, for the unified gateway, we might need path-based routing if we want to hit specific channel admins, 
        # BUT the requirement was a "Unified Gateway". 
        # Since the Admin UI has a "Channel Selector", the API requests likely contain the channel context or go to a central controller.
        # However, we have 4 controller instances. 
        # Current design in V1: AdminController handles all? No, we split them.
        # If we have 4 separate controllers, the Frontend needs to know which one to talk to.
        # OR, we simplified the design in V2 implementation plan to just "shorts-controller-v2-*" and "Unified Gateway".
        # Let's route /api/ requests to `shorts-science-v2` by default for now, or use mapped ports.
        # Wait, the user agreed to "shorts-controller-v2-*" (Internal).
        # We need a strategy here. Since the Frontend is SPA, it calls /api. 
        # We probably need to route /api/science -> shorts-science-v2, etc., or rely on header.
        # For simplicity in this step, let's route to the generic 'shorts-science-v2' as the primary admin interface, 
        # assuming the admin panel can control others via cross-service calls or shared DB? 
        # Actually, the "Channel Selector" in UI usually just changes the `channelId` param.
        # If the controllers are PHYSICALLY separated, /api calls need to be routed to the correct container.
        # Let's verify how the Frontend constructs API calls.
        # Checking `App.tsx` might give a clue.
        # For now, I will map common API paths to shorts-science-v2 as the "Main" controller.
    }
    
    # Specific upstreams for channels if needed
    upstream science { server shorts-science-v2:8080; }
    upstream horror  { server shorts-horror-v2:8080; }
    upstream stocks  { server shorts-stocks-v2:8080; }
    upstream history { server shorts-history-v2:8080; }

    server {
        listen 80;

        # Frontend
        location / {
            proxy_pass http://frontend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
        }

        # Backend API - Dynamic Routing based on header or path?
        # For this setup, we'll route generic /api to science (default)
        # But ideally, the frontend should send a header `X-Channel-Id`.
        # Let's assume simple routing for now.
        location /api/ {
            proxy_pass http://science;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
        
        # We can also expose channel specific endpoints if we modify the frontend to use them
        # location /api/science/ { proxy_pass http://science/; }
        # location /api/horror/ { proxy_pass http://horror/; }
    }
}
