package com.sciencepixel.consumer

import com.sciencepixel.config.KafkaConfig
import com.sciencepixel.domain.VideoHistory
import com.sciencepixel.domain.VideoStatus
import com.sciencepixel.event.KafkaEventPublisher
import com.sciencepixel.event.RssNewItemEvent
import com.sciencepixel.event.ScriptCreatedEvent
import com.sciencepixel.repository.VideoHistoryRepository
import com.sciencepixel.service.GeminiService
import com.sciencepixel.service.LogPublisher
import com.fasterxml.jackson.databind.ObjectMapper
import org.springframework.kafka.annotation.KafkaListener
import org.springframework.stereotype.Component
import java.time.LocalDateTime
import java.util.*

@Component
class ScriptConsumer(
    private val geminiService: GeminiService,
    private val videoHistoryRepository: VideoHistoryRepository,
    private val eventPublisher: KafkaEventPublisher,
    private val logPublisher: LogPublisher,
    private val objectMapper: ObjectMapper
) {

    @KafkaListener(
        topics = [KafkaConfig.TOPIC_RSS_NEW_ITEM],
        groupId = KafkaConfig.GROUP_MAIN
    )
    fun consumeRssItem(message: String) {
        try {
            val event = objectMapper.readValue(message, RssNewItemEvent::class.java)
            logPublisher.info("shorts-controller", "Process Started: ${event.title}", "URL: ${event.url}")
            println("â–¶ï¸ [ScriptConsumer] Received RSS item: ${event.title}")

            // 1. Create or Get History (Idempotency)
            val history = getOrCreateHistory(event)
            
            // ì „ì—­ ì°¨ë‹¨ ìƒíƒœ í™•ì¸ (ì—…ë¡œë“œ ì°¨ë‹¨ ìƒíƒœì´ë©´ ì•„ì˜ˆ ìƒì„±ì„ ì•ˆ í•˜ëŠ” ê²ƒì´ í† í° ì ˆì•½ì— ìœ ë¦¬í•  ìˆ˜ ìˆìŒ)
            // ì—¬ê¸°ì„œëŠ” ì¼ë‹¨ ê¸°ì¡´ ë¡œì§ëŒ€ë¡œ ì§„í–‰í•˜ë˜, ì¤‘ë³µ í˜¸ì¶œ ì²´í¬ë§Œ ê°•í™”í•¨
            
            // ì´ë¯¸ ì™„ë£Œë˜ì—ˆê±°ë‚˜ ì—…ë¡œë“œëœ ê²½ìš° ê±´ë„ˆëœ€
            if (history.status == VideoStatus.COMPLETED || history.status == VideoStatus.UPLOADED) {
                println("âš ï¸ Video already completed/uploaded for: ${event.title}. Skipping Gemini call.")
                return
            }

            // ì´ë¯¸ íŒŒì´í”„ë¼ì¸ ì§„í–‰ ì¤‘ì¸ ê²½ìš° ê±´ë„ˆëœ€
            // (ìƒˆë¡œìš´ ì²´ê³„ì—ì„œëŠ” CREATING ìƒíƒœê°€ ëª¨ë“  ì§„í–‰ ì¤‘ì¸ ìƒíƒœë¥¼ í¬í•¨í•©ë‹ˆë‹¤)
            // ë‹¨, ìµœì´ˆ ìƒì„±ì¸ ê²½ìš°ì—ë„ CREATINGì´ë¯€ë¡œ, ì—¬ê¸°ì„œ getOrCreateHistory ì´í›„ì˜ ìƒíƒœë¥¼ ì„¸ë°€í•˜ê²Œ ë³¼ í•„ìš”ê°€ ì—†ìœ¼ë©´ ê·¸ëŒ€ë¡œ ë‘¡ë‹ˆë‹¤.
            // ì—¬ê¸°ì„œëŠ” ì¤‘ë³µ ë°œí–‰ ë°©ì§€ë¥¼ ìœ„í•´ ì²´í¬í•©ë‹ˆë‹¤.
            // 5ë¶„ ì´ë‚´ ì¤‘ë³µ ì²´í¬ ë¡œì§ ì œê±° (VideoProcessorê°€ ì´ë¯¸ CREATINGìœ¼ë¡œ ìƒì„±í•´ì„œ ë„˜ê¸°ë¯€ë¡œ ì—¬ê¸°ì„œ ë§‰í˜)
            // if (history.status == VideoStatus.CREATING && history.updatedAt.isAfter(LocalDateTime.now().minusMinutes(5))) {
            //      println("â­ï¸ Video already in pipeline (Status: ${history.status}) for: ${event.title}. Skipping Gemini call to save tokens.")
            //      return
            // }

            // 2. Call Gemini
            println("ğŸ¤– generating script for: ${event.title}...")
            val scriptResponse = geminiService.writeScript(event.title, event.title) // RSS summary might be null, use title or fetch content if needed

            if (scriptResponse.scenes.isEmpty()) {
                println("âš ï¸ Empty script generated. Marking as FAILED.")
                videoHistoryRepository.save(history.copy(
                    status = VideoStatus.FAILED,
                    failureStep = "SCRIPT",
                    errorMessage = "Empty script generated by Gemini",
                    updatedAt = LocalDateTime.now()
                ))
                return
            }

            // 3. Update History with Script Data (Stay in CREATING)
            val updatedHistory = videoHistoryRepository.save(history.copy(
                status = VideoStatus.CREATING,
                title = scriptResponse.title,
                description = scriptResponse.description,
                tags = scriptResponse.tags,
                sources = scriptResponse.sources,
                updatedAt = LocalDateTime.now()
            ))

            // 4. Publish next event
            eventPublisher.publishScriptCreated(ScriptCreatedEvent(
                videoId = updatedHistory.id!!,
                title = scriptResponse.title,
                script = objectMapper.writeValueAsString(scriptResponse.scenes), // Serialize scenes to string to pass along
                summary = scriptResponse.description,
                sourceLink = event.url,
                keywords = scriptResponse.tags
            ))

            logPublisher.info("shorts-controller", "Script Generated: ${scriptResponse.title}", "Scenes: ${scriptResponse.scenes.size}ea", traceId = updatedHistory.id)
            println("âœ… [ScriptConsumer] Script created & event published: ${event.title}")

        } catch (e: Exception) {
            logPublisher.error("shorts-controller", "Script Generation Failed", "Error: ${e.message}")
            println("âŒ [ScriptConsumer] Error: ${e.message}")
            e.printStackTrace()
            // Mark as FAILED in DB
            val event = objectMapper.readValue(message, RssNewItemEvent::class.java)
            videoHistoryRepository.findByLink(event.url)?.let { 
                videoHistoryRepository.save(it.copy(
                    status = VideoStatus.FAILED, 
                    failureStep = "SCRIPT",
                    errorMessage = e.message ?: "Unknown Script Generation Error",
                    updatedAt = LocalDateTime.now()
                ))
            }
        }
    }

    private fun getOrCreateHistory(event: RssNewItemEvent): VideoHistory {
        // Simple check by link (assuming unique per news)
        val existing = videoHistoryRepository.findByLink(event.url)
        if (existing != null) return existing

        val initialVideo = VideoHistory(
            id = UUID.randomUUID().toString(),
            title = event.title,
            summary = "", // Initial summary
            link = event.url,
            status = VideoStatus.CREATING,
            createdAt = LocalDateTime.now(),
            updatedAt = LocalDateTime.now()
        )
        return try {
            videoHistoryRepository.save(initialVideo)
        } catch (e: org.springframework.dao.DuplicateKeyException) {
            println("âš ï¸ Race condition detected for link: ${event.url}. Returning existing record.")
            videoHistoryRepository.findByLink(event.url) ?: throw IllegalStateException("Record should exist but not found: ${event.url}")
        } catch (e: Exception) {
             // Fallback for other potential race conditions or DB errors
             val checkAgain = videoHistoryRepository.findByLink(event.url)
             if (checkAgain != null) return checkAgain
             throw e
        }
    }
}
